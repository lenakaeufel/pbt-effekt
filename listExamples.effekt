import generator
import propertyTest

def main() = {
  println(suite("My Tests") {
    unittest("1 + 1 == 2") {
      assertEqual(1 + 1, 2)
    }

    unittest("2 + 2 == 3") {
      assertEqual(2 + 2, 3)
    }

    with arbitraryInt;
    forall[Int]("reverse[x] === [x]", 100){ x => 
      assertEqual(
        reverse([x]),
        [x]
      )
    }

    with def g = arbitraryInt;
    forall[Int]("reverse[x] === [x], explicitely passing the generator", 100){ g }{ x => 
      assertEqual(
        reverse([x]),
        [x]
      )
    }

  forall[Int]("reverse[x] === [6]", 100){ x => 
      assertEqual(
        reverse([x]),
        [6]
      )
    }
  
  exists[Int]("Is the Integer 2 being generated?", 100)
    { x => 
      assertEqual(
        x,
        2
      )
    }
    
  with arbitraryList[Int](3) 
  forall[List[Int], List[Int]]("reverse: distributivity over append", 100)
    { (xs, ys) => 
      assertEqual(
        reverse(xs.append(ys)), 
        reverse(ys).append(reverse(xs))
      )
    }

  forall[List[Int], List[Int]]("reverse: distributivity mistake - swapped order", 20)
      { (xs, ys) => 
        assertEqual(
          reverse(xs.append(ys)), 
          reverse(xs).append(reverse(ys))
        )
      }

  with arbitraryChar; 
  with arbitraryList[Char](4);
  forall[List[Char], List[Int]]("|zip(xs,ys)| === min(|xs|,|ys|)",10)
    { (xs, ys) =>
      assertEqual(
        zip(xs, ys).size,
        min(xs.size, ys.size)
      )
    }

  with arbitraryChar; 
  with arbitraryList[Char](6);
  forall[List[Char], List[Int]]("intended mistake: |zip(xs,ys)| != max(|xs|,|ys|)",10)
    { (xs, ys) =>
      assertEqual(
        zip(xs, ys).size,
        max(xs.size, ys.size)
      )
    }

  with arbitraryChar;
  with arbitraryString(4);
  with arbitraryList[String](2);
  with arbitraryInt;
  with arbitraryList[Int](3)
  forall[List[Int], List[String]]("unzip(zip(xs,ys)) === (xs.take(m), ys.take(m)) where m = min(|xs|,|ys|)", 10)
    { (xs, ys) =>
      val m = min(xs.size, ys.size)
      assertEqual(
        unzip(zip(xs, ys)),
        (xs.take(m), ys.take(m))
      )
    }

  // Dropping elements from the concatenation of two lists is equivalent to dropping elements from the first list, 
  // and then (if necessary) dropping the remaining count from the second list.
  forall[List[Int], List[Int], Int]("(xs ++ ys).drop(n) === if n <= len(xs) then (xs.drop(n)) ++ ys else ys.drop(n - len(xs))", 10)
    { (xs, ys, n) =>
      var res = if(n <= xs.size){
        xs.drop(n).append(ys) } 
        else{ ys.drop(n - xs.size) }
      assertEqual(
        (xs.append(ys).drop(n)),
        res
      )
    }

  forall[List[Int], Int]("xs.drop(n) === xs.slice(n, x.size)", 10)
    { (xs, n) =>
      assertEqual(
        xs.drop(n),
        xs.slice(n, xs.size)
      )
    }

  forall[List[Int], List[Int]]("reverseOnto(reverse(xs), ys) === append(xs, ys)", 10)
    { (xs, ys) =>
      assertEqual(
        reverseOnto(reverse(xs), ys),
        append(xs, ys)
        )
    }
  
  forall[List[Int]]("size(xs) === foldLeft(xs, 0) { (acc, _) => acc + 1 }", 20)
    { xs =>
      assertEqual(
        size(xs),
        foldLeft(xs, 0){(acc, _) => acc + 1}
      )
    }

  forall[Int, List[Int]]("xs.take(n) ++ xs.drop(n) === xs", 20)
    { (n, xs) =>
      assertEqual(
        append(xs.take(n), xs.drop(n)),
        xs
      )
    }

  with evenNumbers;
  forall[Int]("even numbers are even and smaller than 4", 20)
    { n =>
      assertTrue(n.mod(2) == 0)
      assertTrue(n <= 4)
    }
  })
}
    
